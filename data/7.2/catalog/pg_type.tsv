Index	Name	Type	References	Description
0	typname	NAME			"data type name"
1	typowner	INT4		pg_shadow.usesysid	"owner (creator) of the type"
2	typlen	INT2			"length of the storage representation of the type, -1 if variable length"
3	typprtlen	INT2			unused
4	typbyval	BOOL			"typbyval determines whether internal routines pass a value of this type by value or by reference. only char, short, and int equivalent items can be passed by value, so if the type is not 1, 2, or 4 bytes long, postgresql does not have the option of passing by value and so typbyval had better be false. variable-length types are always passed by reference. note that typbyval can be false even if the length would allow pass-by-value; this is currently true for type float4, for example."
5	typtype	CHAR			"typtype is b for a base type and c for a complex type (i.e., a table's row type). if typtype is c, typrelid is the oid of the type's entry in pg_class."
6	typisdefined	BOOL			"true if the type is defined, false if this is a placeholder entry for a not-yet-defined type. when typisdefined is false, nothing except the type name and oid can be relied on."
7	typdelim	CHAR			"character that separates two values of this type when parsing array input. note that the delimiter is associated with the array element datatype, not the array datatype."
8	typrelid	OID		pg_class.oid	"if this is a complex type (see typtype), then this field points to the pg_class entry that defines the corresponding table. a table could theoretically be used as a composite data type, but this is not fully functional."
9	typelem	OID		pg_type.oid	"if typelem is not 0 then it identifies another row in pg_type. the current type can then be subscripted like an array yielding values of type typelem. a ""true"" array type is variable length (typlen = -1), but some fixed-length (typlen > 0) types also have nonzero typelem, for example name and oidvector. if a fixed-length type has a typelem then its internal representation must be n values of the typelem datatype with no other data. variable-length array types have a header defined by the array subroutines."
10	typinput	REGPROC			"input function"
11	typoutput	REGPROC			"output function"
12	typreceive	REGPROC			unused
13	typsend	REGPROC			unused
14	typalign	CHAR			"typalign is the alignment required when storing a value of this type. it applies to storage on disk as well as most representations of the value inside postgresql. when multiple values are stored consecutively, such as in the representation of a complete row on disk, padding is inserted before a datum of this type so that it begins on the specified boundary. the alignment reference is the beginning of the first datum in the sequence. possible values are: 'c' = char alignment, i.e., no alignment needed. 's' = short alignment (2 bytes on most machines). 'i' = int alignment (4 bytes on most machines). 'd' = double alignment (8 bytes on many machines, but by no means all). note: for types used in system tables, it is critical that the size and alignment defined in pg_type agree with the way that the compiler will lay out the field in a struct representing a table row."
15	typstorage	CHAR			"typstorage tells for variable-length types (those with typlen = -1) if the type is prepared for toasting and what the default strategy for attributes of this type should be. possible values are 'p': value must always be stored plain. 'e': value can be stored in a ""secondary"" relation (if relation has one, see pg_class.reltoastrelid). 'm': value can be stored compressed inline. 'x': value can be stored compressed inline or in ""secondary"". note that 'm' fields can also be moved out to secondary storage, but only as a last resort ('e' and 'x' fields are moved first)."
16	typdefault	TEXT			"typdefault is null for types without a default value. if it's not null, it contains the external string representation of the type's default value."
